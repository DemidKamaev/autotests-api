import grpc
from concurrent import futures
import user_service_pb2
import user_service_pb2_grpc


# создаем класс и из файла user_service_pb2_grpc
# импортируем UserServiceServicer, который по дефолту он имплементирован
# и под дефолту он возвращает статус код Method not implemented!
# он говорит, что там его нужно имплементировать
# по факту, если мы сейчас просто возьмем класс UserServiceServicer и
# запустим его в качестве сервера, у нас будет работать gRPC сервер
# Но он будет возвращать ошибку: выбрасывать нам исключение raise

# в атрибутах класса добавляем модуль файла и наследуем(.) наш класс от этого класса,
# который у нас не имплементированный
# и имплементируем GetUser: нам необходимо прописать сейчас ему логику
class UserServiceServicer(user_service_pb2_grpc.UserServiceServicer):
    def GetUser(self, request, context):
        print(f"Получен запрос к методу GetUser от пользователя: {request.username}")
        return user_service_pb2.GetUserResponse(message=f"Привет, {request.username}")

# request - это наш запрос: message GetUserRequest {
#     string username = 1;
# }
# то есть нам придет какая-то модель с username

# context - это те же самые заголовки, которые мы передаем в http запросе
# т.е. какая-то любая метаинфа

# принт напечатаем: указываем имя пользоваетля
# который придет у нас откуда?
# У нас есть модель запроса: возьмем username из нее
# message GetUserRequest {
#     string username = 1;
# }
# Соотвественно нам приходит в request модель запроса

# return: вернем ответ, то есть вернуть модель GetUserResponse
# Все модели сгенерированы у нас в файле user_service_pb2:
# Они динамически здесь генерируются
# Мы используем данный файл user_service_pb2.GetUserResponse
# и возвращать будет message из данной модели
# Мы определяем поле message и передать туда какую-то строку
# message=f"Привет, {request.username}"

# Мы написали простенький эхо сервер, который на вход получит
# Имя пользователя и вернет его в ответе

# *** То есть мы просто определяем контракт нашего сервиса
# Пишем, как мы будем взаимодействовать, описывая наш gRPC сервис
# Далее мы этот gRPC сервис имплементируем с точки зрения сервера
# И нам необходимо его запустить, пишем def server + импорт from concurrent import futures


def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))

    user_service_pb2_grpc.add_UserServiceServicer_to_server(UserServiceServicer(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    print("gRPC сервер запущен на порту 50051...")
    server.wait_for_termination()


if __name__ == '__main__':
    serve()

    # макимально для нашего воркера будет 10 штук
    # далее обращаемся к этому модулю
    # Здесь у нас автоматически генерируется функция(метод), которая позволяет
    # нам вот этот Сервайсер UserServiceServicer добавить к нашему grpc
    # серверу: в данном методе передать наш класс UserServiceServicer() и передать сам server,
    # куда мы хотим добавить наш сервис

    # Далее необходимо сказать нашему серверу add_insecure_port()
    # Здесь мы запускаем все локально, поэтому он нам не нужен
    # [::]:50051 - мы запускаем на localhost и указываем 50051 порт
    # по этому порту мы можем обратиться к нашему сервису, т.е.
    # по адресу localhost по порту 50051
    # Далее используем метод start() и принт
    # Далее делаем это бесконечным циклом, чтобы сервер после запуска
    # не завершался wait_for_termination()
    # То есть пока мы его не завершим: cntr+C

    # и пишем через if запуск нашей функции serve(), которая
    # инициализирует наш сервер
    # Зачем это нужно? Если мы захотим импортировать эту функцию
    # в другой модуль(в другой файл), у нас она автоматически не вызывалась
    # А вызвалась только в том случае, если мы напрямую ее запустим

    # *Запустим наш сервер, пока клиента у нас нет

